#+TITLE: INFO-F-403 -- Project
#+AUTHOR: Vadim Baele -- Quentin Stievenart
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t todo:nil
#+LATEX_HEADER: \usepackage[a4paper]{geometry}
#+LATEX_HEADER: \geometry{hscale=0.7,vscale=0.7,centering}
#+LATEX_HEADER: \usepackage[pdftex]{hyperref}
#+LATEX_HEADER: \hypersetup{colorlinks,citecolor=black,filecolor=black,linkcolor=black,urlcolor=black}
#+LATEX_HEADER: \usepackage{syntax}
#+LATEX_HEADER: \usepackage{listings}
The purpose of this project is to develop a compiler for a simplified
version of Perl, that compiles to ARM assembler, in order to be able
to execute compiled Perl code on Android devices. The simplified
version of Perl to be implemented is described in the project statement.
* Lexer
** Lexical Units
The lexical units of this simplified version of Perl are given here,
with their regular expression and and  the corresponding token used in
the implementation. While each of the lexical unit have a
different token name, some are grouped into categories for a matter of
clarity.

  - *Symbols*:
    - ={=: =LBRACE=
    - =}=: =RBRACE=
    - =(=: =LPAR=
    - =)=: =RPAR=
    - =;=: =SEMICOLON=
    - \texttt{,}: =COMMA=
    - =&=: =CALL_MARK=
    - \texttt{\=}: =ASSIGN=
  - *Operators*:
    - =+=: =PLUS=
    - =-=: =MINUS=
    - =*=: =TIMES=
    - =/=: =DIVIDE=
    - =||=: =LAZY_OR=
    - =&&=: =LAZY_AND=
    - \texttt{\=\=}: =EQUALS=
    - \texttt{!=}: =DIFFERENT=
    - =>=: =GREATER=
    - =<=: =LOWER=
    - \texttt{>=}: =GREATER_EQUALS=
    - \texttt{<=}: =LOWER_EQUALS=
    - =eq=: =STRING_EQUALS=
    - =ne=: =STRING_DIFFERENT=
    - =gt=: =STRING_GREATER=
    - =ge=: =STRING_GREATER_EQUALS=
    - =lt=: =STRING_LOWER=
    - =le=: =STRING_LOWER_EQUALS=
    - =not=: =NOT_WORD=
    - =!=: =NOT=
  - *Keywords*:
    - =if=: =IF=
    - =unless=: =UNLESS=
    - =else=: =ELSE=
    - =elsif=: =ELSEIF=
    - =return=: =RETURN=
    - =sub=: =SUB=
  - *Integer*: =[0-9]+=: =INTEGER=
  - *String*: =("[^"]"|'[^']')=: =STRING=
  - *Identifier*: =[a-zA-Z][a-zA-Z0-9]*=: =IDENTIFIER=
  - *Variable*: =$[a-zA-Z0-9]+=: =VARIABLE=
** Deterministic Finite Automaton
The DFA is divided in multiple figure for a matter of clarity. All the
following figures have the same start state, and some refer to the
special state =to identifier=, which /redirects/ the DFA into the
corresponding figure. The accepting states are represented with states
with dashed lines.

\begin{figure}
\centerline{\includegraphics[width=0.7\textwidth]{dfa.png}}
\caption{DFA for single character symbols, spaces and comments}
\end{figure}

\begin{figure}
\centerline{\includegraphics[width=0.7\textwidth]{dfa-multi-char-sym.png}}
\caption{DFA for multi-character symbols}
\end{figure}

\begin{figure}
\centerline{\includegraphics[width=0.7\textwidth]{dfa-int-string.png}}
\caption{DFA for integer and strings}
\end{figure}

\begin{figure}
\centerline{\includegraphics[width=0.7\textwidth]{dfa-var-identifier.png}}
\caption{DFA for variables and identifiers}
\end{figure}

\begin{figure}
\centerline{\includegraphics[width=1.45\textwidth]{dfa-keywords.png}}
\caption{DFA for keywords}
\end{figure}

\begin{figure}
\centerline{\includegraphics[width=\textwidth]{dfa-e.png}}
\caption{DFA for keywords starting with \texttt{e}}
\end{figure}

** Implementation
The different tokens are defined as a type (in =token.ml=). The lexer
(or scanner) is implemented in =hand_lexer.ml= and its implementation
is a simple translation from the DFA to OCaml code, which looks the
next character from the input stream and goes to the corresponding
state. The main function of the lexer has the following type
signature:

#+BEGIN_SRC caml
val lex : in_channel -> (string, token) either Stream.t
#+END_SRC

Which means that the lexer reads its input from an input channel
(=stdin= or a file), and it outputs a stream of =(string, token)
either=, meaning that the stream can contain either a token, or a
string (which describes a lexing error).

Another lexer is implemented with Ocamllex, in =ocamllex_lexer.ml=,
and the user can choose between the two implementations using the =-l=
flag when calling the compiler.
* Parser
** Modified grammar
The grammar used is a modification of the first grammar given (in the
project statement). This modified is given below.

\setlength{\grammarparsep}{20pt plus 1pt minus 1pt}
\setlength{\grammarindent}{12em}
\begin{grammar}
\input{grammar.tex}
\end{grammar}

The differences between this grammar and the grammar given in the
project's statement are the following:
  - =<program>=: a program should consist first of the function
    definition and then of the program instruction, else it would
    cause problems in the parsing table
  - =<instr list>=: every instruction has to end with a semicolon,
    else the first and follow sets of every non-terminals would be
    really big and the chances of having a conflict would grow.
  - =<funcall>=: functions can now be called without being prefixed by a
    =&=
  - =<funcall args>=: function calls now have mandatory parentheses,
    to avoid conflicts
  - =<instr>= and =<cond>=: post-condition forms are now in this
    non-terminal, to avoid conflicts (since now =<cond>= cannot start
    with an =<expr>=)
  - =<cond end>=: the =else= branch was incorrect
  - =<expr>=: the old =<expr>= non-terminal has been splitted in
    multiple non-terminals in order to respect the operators'
    precedences

** LL(1) grammar
The grammar has been converted to a LL(1) grammar by
eliminating left-recursion, and the result is given below. A =<S>=
non-terminal symbol has been added to handle the =EOF= character,
needed to properly implement the grammar.

\setlength{\grammarparsep}{20pt plus 1pt minus 1pt}
\setlength{\grammarindent}{12em}
\begin{grammar}
\input{grammar-ll1.tex}
\end{grammar}

** First and follows
The /first/ and /follow/ sets of the different non-terminal symbol are
given below.

\setlength{\grammarparsep}{0.25cm}
\setlength{\grammarindent}{1cm}
\begin{grammar}
\input{first-follow.tex}
\end{grammar}
** Parsing Table
** Grammar decoration
** Implementation
* Code generation
** Implementation
